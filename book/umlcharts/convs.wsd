@startuml

    class conv_type {
        <<singleton>>
        +MAX_L4_CONVERSATIONS: int = 50000
        +GLOBAL_L4_EXT: string = "_L4.json"
        +DEBUG: int = 0
        +search_params(conv: conv_s, search: search_e, ret_type: search_ret_e, optional_a: void*, optional_b: void*, optional_c: void*): void*
        +get_last_packet_bt(p_list: packet_node_s*, end_time: double): packet_node_s*
        +get_first_packet_bt(p_list: packet_node_s*, start_time: double): packet_node_s*
    }

  class conv {
        +print_output_to_file(conversations: conv_s[MAX_L4_CONVERSATIONS], filename: char*): void
        +print_packet_list(root: packet_node_s**, packet_count: int): void
        +print_packets(conversations: conv_s[MAX_L4_CONVERSATIONS]): void
        +compare_L4_conversations(a: void*, b: void*): int
        +conversation_hash(conversation: conv_s*): unsigned int
        +invalid_files(pcap_file: char*, output_file: char*): int
        +add_packet_to_list(root: packet_node_s**, original_packet: u_char*, packet_size: size_t, id: uint32_t, seq: uint32_t, ack: uint32_t, src_ip: struct in_addr, dest_ip: struct in_addr, timestamp: struct timeval, relative_time: double): int
        +check_retransmission(p: packet_node_s*, atob: packet_node_s*, btoa: packet_node_s*): int
        +analyze_conversations(conversations_arr: conv_s[MAX_L4_CONVERSATIONS]): void
        +save_L4_convs_to_json(filename: const char*): void
        +init_list(root: packet_node_s**): void
        +packet_handler(user: u_char*, pkthdr: struct pcap_pkthdr*, packet: u_char*): void
        +free_all_lists(): void
        +free_all_l4_convs(conversations: conv_s[MAX_L4_CONVERSATIONS]): void
        +free_l4_list(root: packet_node_s**): void
    }

    struct conv_s {
        uint16_t conv_id
        uint16_t src_port
        uint16_t dest_port
        struct in_addr src_ip
        struct in_addr dest_ip
        int packets_from_a_to_b
        int packets_from_b_to_a
        int proto_type
        int num_packets
        int num_exep
        packet_exep_node_s exep_packet_id[MAX_EXEP]
        packet_node_s *packet_list
    }

    struct packet_node_s {
        u_char *packet_data
        uint32_t p_id
        size_t packet_size
        size_t packet_type
        size_t packet_exep
        uint32_t num_seq
        uint32_t num_ack
        uint8_t flags
        uint16_t win_size
        struct in_addr src_ip
        struct in_addr dest_ip
        struct timeval time_stamp
        double time_stamp_rltv
        packet_node_s *next
    }
  
  enum packet_type_e {
        FIN_P_TYPE = TH_FIN,
        SYN_P_TYPE = TH_SYN,
        RST_P_TYPE = TH_RST,
        PSH_P_TYPE = TH_PUSH,
        ACK_P_TYPE = TH_ACK,
        URG_P_TYPE = TH_URG,
        ZERO_WINDOW_TYPE = 1111,
        ERR_P_TYPE = -1
    }

    enum packet_exep_e {
        NORMAL_EXEP = 21,
        DUP_ACK_ATOB_EXEP,
        DUP_ACK_BTOA_EXEP,
        ZERO_WINDOW_EXEP,
        TIMEOUT_EXEP,
        RETRANS_EXEP,
        RESET_EXEP
    }

    enum packet_flags {
        NO_FLAGS = 0,
        FIN_FLAG = 1 << 0,
        SYN_FLAG = 1 << 1,
        RST_FLAG = 1 << 2,
        PSH_FLAG = 1 << 3,
        ACK_FLAG = 1 << 4,
        URG_FLAG = 1 << 5,
        ZERO_WINDOW_FLAG = 1 << 6,
        RETRANS_FLAG = 1 << 7
    }

@enduml
